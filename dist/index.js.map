{"version":3,"sources":["../src/core/types.ts","../src/core/plugin.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import { JSX } from \"react\";\n\n/**\n * Supported file types for analysis\n * @public\n */\nexport const FileType = {\n  CSV: 'csv',\n  XLSX: 'xlsx',\n  JSON: 'json',\n} as const;\n\nexport type FileType = (typeof FileType)[keyof typeof FileType];\n\n/**\n * Column data type definitions\n * @public\n */\nexport const ColumnType = {\n  STRING: 'string',\n  NUMBER: 'number',\n  BOOLEAN: 'boolean',\n  DATE: 'date',\n} as const;\n\nexport type ColumnType = (typeof ColumnType)[keyof typeof ColumnType];\n\n/**\n * Represents a column in a dataset\n * @public\n */\nexport interface Column {\n  /** Unique identifier for the column */\n  id: string;\n  /** Display name of the column */\n  name: string;\n  /** Data type of the column */\n  type: ColumnType;\n  /** Additional metadata about the column */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Core dataset that plugins will analyze\n * @public\n */\nexport interface DataSet {\n  /** Array of column definitions */\n  columns: Column[];\n  /** Array of data rows */\n  rows: Record<string, unknown>[];\n  /** Total number of rows in the dataset */\n  totalRows: number;\n  /** Total number of columns in the dataset */\n  totalColumns: number;\n  /** Type of file the data came from */\n  fileType: FileType;\n  /** Additional metadata about the dataset */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Result of plugin analysis\n * @public\n */\nexport interface AnalysisResult {\n  /** Analysis output data */\n  data: Record<string, unknown>;\n  /** Optional error message */\n  error?: string;\n  /** Optional warning messages */\n  warnings?: string[];\n  /** Metadata about the analysis */\n  metadata?: {\n    executionTime?: number;\n    processedRows?: number;\n    processedColumns?: string[];\n  };\n}\n\n/**\n * Props passed to plugin's UI component\n * @public\n */\nexport interface PluginComponentProps {\n  /** Analysis results to display */\n  result: AnalysisResult;\n  /** Dataset that was analyzed */\n  data: DataSet;\n  /** Callback when component should close */\n  onClose?: () => void;\n  /** Optional className for styling */\n  className?: string;\n}\n\nexport type PluginComponentType = (props: PluginComponentProps) => JSX.Element;\n\n/**\n * Plugin configuration derived from package.json\n * @public\n */\nexport interface PluginConfig {\n  /** Plugin name */\n  name: string;\n  /** Plugin version */\n  version: string;\n  /** Plugin description */\n  description: string;\n  /** Plugin author */\n  author: string;\n  /** Entry point file */\n  main: string;\n  /** Supported file types */\n  supportedFileTypes: FileType[];\n  /** Plugin category */\n  category?: 'analysis' | 'visualization' | 'export' | 'utility';\n  /** Search tags */\n  tags?: string[];\n}\n\n/**\n * Options for analysis execution\n * @public\n */\nexport interface AnalysisOptions {\n  /** Columns to include in analysis */\n  selectedColumns?: string[];\n  /** Additional parameters */\n  parameters?: Record<string, unknown>;\n}\n\n/**\n * Plugin error with additional context\n * @public\n */\nexport class PluginError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public details?: Record<string, unknown>\n  ) {\n    super(message);\n    this.name = 'PluginError';\n  }\n}\n\n/**\n * Common error codes that can be thrown by plugins\n * @public\n */\nexport const ErrorCode = {\n  INVALID_DATA: 'INVALID_DATA',\n  UNSUPPORTED_FILE_TYPE: 'UNSUPPORTED_FILE_TYPE',\n  MISSING_REQUIRED_COLUMNS: 'MISSING_REQUIRED_COLUMNS',\n  ANALYSIS_FAILED: 'ANALYSIS_FAILED',\n  VALIDATION_ERROR: 'VALIDATION_ERROR',\n} as const;\n\nexport type ErrorCode = (typeof ErrorCode)[keyof typeof ErrorCode];\n","import {\n  AnalysisResult,\n  PluginConfig,\n  DataSet,\n  AnalysisOptions,\n  PluginError,\n  ErrorCode,\n  FileType, PluginComponentType,\n} from './types';\n\n/**\n * Base class for all plugins\n * @public\n */\nexport abstract class Plugin {\n  protected config: PluginConfig;\n\n  constructor(config: PluginConfig) {\n    this.validateConfig(config);\n    this.config = config;\n  }\n\n  /**\n   * Analyze the provided dataset\n   * @param data - Dataset to analyze\n   * @param options - Optional analysis configuration\n   * @throws {PluginError} When analysis fails\n   */\n  abstract analyze(data: DataSet, options?: AnalysisOptions): Promise<AnalysisResult>;\n\n  /**\n   * React component to display analysis results\n   */\n  abstract get Component(): PluginComponentType;\n\n  /**\n   * Get plugin identifier\n   */\n  getId(): string {\n    return this.config.name;\n  }\n\n  /**\n   * Get plugin display name\n   */\n  getName(): string {\n    return this.config.name;\n  }\n\n  /**\n   * Get plugin description\n   */\n  getDescription(): string {\n    return this.config.description;\n  }\n\n  /**\n   * Check if plugin supports given file type\n   */\n  supportsFileType(fileType: FileType): boolean {\n    return this.config.supportedFileTypes.includes(fileType);\n  }\n\n  /**\n   * Get supported file types\n   */\n  getSupportedFileTypes(): FileType[] {\n    return this.config.supportedFileTypes;\n  }\n\n  /**\n   * Validate dataset before analysis\n   * @throws {PluginError} When validation fails\n   */\n  protected validateDataSet(data: DataSet): void {\n    if (!data.columns?.length || !data.rows?.length) {\n      throw new PluginError('Dataset must contain columns and rows', ErrorCode.INVALID_DATA);\n    }\n\n    if (!this.supportsFileType(data.fileType)) {\n      throw new PluginError(\n        `Unsupported file type: ${data.fileType}`,\n        ErrorCode.UNSUPPORTED_FILE_TYPE\n      );\n    }\n  }\n\n  private validateConfig(config: PluginConfig): void {\n    if (!config.name || !config.version || !config.supportedFileTypes?.length) {\n      throw new Error('Invalid plugin configuration');\n    }\n\n    // Validate all file types are supported\n    config.supportedFileTypes.forEach((type) => {\n      if (!Object.values(FileType).includes(type)) {\n        throw new Error(`Invalid file type: ${type}`);\n      }\n    });\n  }\n}\n\n/**\n * Registry for managing plugins\n * @public\n */\nexport class PluginRegistry {\n  private plugins: Map<string, Plugin> = new Map();\n\n  /**\n   * Register a new plugin\n   * @throws {Error} If plugin is already registered\n   */\n  registerPlugin(plugin: Plugin): void {\n    if (this.plugins.has(plugin.getId())) {\n      throw new Error(`Plugin ${plugin.getId()} is already registered`);\n    }\n    this.plugins.set(plugin.getId(), plugin);\n  }\n\n  /**\n   * Unregister a plugin\n   */\n  unregisterPlugin(id: string): void {\n    this.plugins.delete(id);\n  }\n\n  /**\n   * Get a plugin by ID\n   */\n  getPlugin(id: string): Plugin | undefined {\n    return this.plugins.get(id);\n  }\n\n  /**\n   * Get all plugins that support a specific file type\n   */\n  getPluginsForFileType(fileType: FileType): Plugin[] {\n    return Array.from(this.plugins.values()).filter((plugin) => plugin.supportsFileType(fileType));\n  }\n\n  /**\n   * Get all registered plugins\n   */\n  getAllPlugins(): Plugin[] {\n    return Array.from(this.plugins.values());\n  }\n}\n\n/**\n * Execute plugin analysis with validation and error handling\n * @public\n */\nexport async function executePluginAnalysis(\n  plugin: Plugin,\n  data: DataSet,\n  options?: AnalysisOptions\n): Promise<AnalysisResult> {\n  try {\n    plugin['validateDataSet'](data);\n    return await plugin.analyze(data, options);\n  } catch (error) {\n    if (error instanceof PluginError) {\n      throw error;\n    }\n    throw new PluginError(\n      'Analysis failed: ' + (error as Error).message,\n      ErrorCode.ANALYSIS_FAILED,\n      { originalError: error }\n    );\n  }\n}\n"]}